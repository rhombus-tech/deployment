#[cfg(test)]
mod solidity_checks_tests {
    use crate::bytecode::BytecodeAnalyzer;
    use ethers::types::{Bytes, U256};
    use hex_literal::hex;
    use anyhow::Result;

    #[test]
    fn test_detect_solidity_checks() -> Result<()> {
        let bytecode = Bytes::from(hex!(
            "608060405234801561001057600080fd5b50610304806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80639ec5a89414610030575b600080fd5b61004a600480360381019061004591906100c9565b610060565b60405161005791906100f5565b60405180910390f35b60008173ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600080516020610283833981519152600080516020610283833981519152604051610138929190610218565b60405180910390a3600080516020610283833981519152600080516020610283833981519152604051610169929190610218565b60405180910390a360405160200161018091906102a8565b6040516020818303038152906040528051906020012060001c9050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006101d68261018b565b9050919050565b6101e6816101cb565b81146101f157600080fd5b50565b600081359050610203816101dd565b92915050565b600081519050610218816101dd565b92915050565b60006040820190506102336000830185610209565b6102406020830184610209565b9392505050565b6000819050919050565b61025a81610247565b82525050565b60006020820190506102756000830184610251565b92915050565b600082825260208201905092915050565b60005b838110156102af578082015181840152602081019050610294565b838111156102be576000848401525b50505050565bfe"
        ));
        
        let mut analyzer = BytecodeAnalyzer::new(bytecode);
        
        // Simulate unchecked call operations that could cause issues
        analyzer.record_memory_allocation(U256::from(0), U256::from(64))?;
        analyzer.record_memory_access(U256::from(0), U256::from(64), true, None)?;

        // Check for unchecked call patterns in memory accesses
        let memory = analyzer.get_memory();
        let has_solidity_checks = memory.accesses.iter().any(|access| {
            access.write && access.size.as_u64() > 32
        });

        assert!(has_solidity_checks, "Should detect Solidity check patterns");
        Ok(())
    }

    #[test]
    fn test_safe_solidity_checks() -> Result<()> {
        let bytecode = Bytes::from(hex!(
            "608060405234801561001057600080fd5b50610304806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80639ec5a89414610030575b600080fd5b61004a600480360381019061004591906100c9565b610060565b60405161005791906100f5565b60405180910390f35b60008173ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600080516020610283833981519152600080516020610283833981519152604051610138929190610218565b60405180910390a3600080516020610283833981519152600080516020610283833981519152604051610169929190610218565b60405180910390a360405160200161018091906102a8565b6040516020818303038152906040528051906020012060001c9050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006101d68261018b565b9050919050565b6101e6816101cb565b81146101f157600080fd5b50565b600081359050610203816101dd565b92915050565b600081519050610218816101dd565b92915050565b60006040820190506102336000830185610209565b6102406020830184610209565b9392505050565b6000819050919050565b61025a81610247565b82525050565b60006020820190506102756000830184610251565b92915050565b600082825260208201905092915050565b60005b838110156102af578082015181840152602081019050610294565b838111156102be576000848401525b50505050565bfe"
        ));
        
        let mut analyzer = BytecodeAnalyzer::new(bytecode);
        
        // Simulate safe call operations
        analyzer.record_memory_allocation(U256::from(0), U256::from(32))?;
        analyzer.record_memory_access(U256::from(0), U256::from(32), true, None)?;

        // Check for unchecked call patterns in memory accesses
        let memory = analyzer.get_memory();
        let has_unsafe_checks = memory.accesses.iter().any(|access| {
            access.write && access.size.as_u64() > 32
        });

        assert!(!has_unsafe_checks, "Should not detect unsafe Solidity check patterns");
        Ok(())
    }
}
