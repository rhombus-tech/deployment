#[cfg(test)]
mod compound_tests {
    use crate::bytecode::analyzer::BytecodeAnalyzer;
    use ethers::types::Bytes;
    use hex_literal::hex;
    use anyhow::Result;

    #[test]
    fn test_detect_compound_overflow() -> Result<()> {
        let bytecode = Bytes::from(hex!(
            "608060405234801561001057600080fd5b50610150806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806374c6f4f114610030575b600080fd5b61004a600480360381019061004591906100c9565b610060565b60405161005791906100f5565b60405180910390f35b600081840190508281029050919050565b600080fd5b6000819050919050565b61008981610076565b811461009457600080fd5b50565b6000813590506100a681610080565b92915050565b6000819050919050565b6100bf816100ac565b81146100ca57600080fd5b50565b6000813590506100dc816100b6565b92915050565b6000602082840312156100f6576100f5610071565b5b600061010484828501610097565b91505092915050565b61011681610076565b82525050565b6000602082019050610131600083018461010d565b9291505056"
        ));

        let mut analyzer = BytecodeAnalyzer::new(bytecode);
        let results = analyzer.analyze()?;

        // Check for compound patterns in memory accesses
        let has_compound = results.memory.accesses.iter().any(|access| {
            access.write && access.size.as_u64() > 32
        });

        assert!(has_compound, "Should detect compound patterns");
        Ok(())
    }

    #[test]
    fn test_detect_compound_division() -> Result<()> {
        let bytecode = Bytes::from(hex!(
            "608060405234801561001057600080fd5b50610150806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a391c15b14610030575b600080fd5b61004a600480360381019061004591906100c9565b610060565b60405161005791906100f5565b60405180910390f35b600081840481019050919050565b600080fd5b6000819050919050565b61008981610076565b811461009457600080fd5b50565b6000813590506100a681610080565b92915050565b6000819050919050565b6100bf816100ac565b81146100ca57600080fd5b50565b6000813590506100dc816100b6565b92915050565b6000602082840312156100f6576100f5610071565b5b600061010484828501610097565b91505092915050565b61011681610076565b82525050565b6000602082019050610131600083018461010d565b9291505056"
        ));

        let mut analyzer = BytecodeAnalyzer::new(bytecode);
        let results = analyzer.analyze()?;

        // Check for compound patterns in memory accesses
        let has_compound = results.memory.accesses.iter().any(|access| {
            access.write && access.size.as_u64() > 32
        });

        assert!(has_compound, "Should detect compound patterns");
        Ok(())
    }

    #[test]
    fn test_safe_compound() -> Result<()> {
        let bytecode = Bytes::from(hex!(
            "608060405234801561001057600080fd5b50610304806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806374c6f4f114610030575b600080fd5b61004a600480360381019061004591906100c9565b610060565b60405161005791906100f5565b60405180910390f35b600080838501905080821015151561007857600080fd5b600082820290508281101515156100008d57600080fd5b8091505092915050565b600080fd5b6000819050919050565b6100b181610098565b81146100bc57600080fd5b50565b6000813590506100ce816100a8565b92915050565b600081519050610218816101dd565b92915050565b60006040820190506102336000830185610209565b6102406020830184610209565b9392505050565b6000819050919050565b61025a81610247565b82525050565b60006020820190506102756000830184610251565b92915050565b600082825260208201905092915050565b60005b838110156102af578082015181840152602081019050610294565b838111156102be576000848401525b50505050565bfe"
        ));

        let mut analyzer = BytecodeAnalyzer::new(bytecode);
        let results = analyzer.analyze()?;

        // Check for safe compound patterns in memory accesses
        let has_safe_compound = results.memory.accesses.iter().all(|access| {
            !access.write || (access.size.as_u64() <= 32 && access.offset.as_u64() > 0)
        });

        assert!(has_safe_compound, "Should detect safe compound patterns");
        Ok(())
    }
}
